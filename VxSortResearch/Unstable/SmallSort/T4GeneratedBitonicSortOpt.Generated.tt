<#@ template language="C#" #>
<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
// <auto-generated>
//     This code was generated by a tool on <#= $"{DateTime.UtcNow.ToString("yyyy-MM-dd-HH:mm:ss")}"#>
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>

using System;
using System.Diagnostics;
using System.Runtime.CompilerServices;
using System.Runtime.Intrinsics;
using static System.Runtime.Intrinsics.X86.Avx;
using static System.Runtime.Intrinsics.X86.Avx2;

namespace VxSortResearch.Unstable.SmallSort
{
    static unsafe partial class T4GeneratedBitonicSortOpt<T>
    {
<#
    static uint GetNextPowerOf2(uint v)
    {
        v--;
        v |= v >> 1;
        v |= v >> 2;
        v |= v >> 4;
        v |= v >> 8;
        v |= v >> 16;
        v++;
        return v;
    }

    // Map supported native types to function suffixes
    Dictionary<string, string> BitonicTypeMap = new Dictionary<string, string> {
        {"int", "Int32"},
        {"uint", "UInt32"},
        {"float", "Single"},
        {"long", "Int64"},
        {"ulong", "UInt64"},
        {"double", "Double"},
    };

    // Map supported native types to function suffixes
    Dictionary<string, int> BitonicSizeMap = new Dictionary<string, int> {
        {"int", 4},
        {"uint", 4},
        {"float", 4},
        {"long", 8},
        {"ulong", 8},
        {"double", 8},
    };
    ICollection<string> BitonicTypes = BitonicTypeMap.Keys;

    string GenerateParamList(uint start, uint numParams)
        => string.Join(", ", Enumerable.Range((int) start, (int) numParams).Select(p => $"ref d{p:00}"));

    string GenerateParamDefList(uint numParams, string nativeType)
        => string.Join(", ", Enumerable.Range(1, (int) numParams).Select(p => $"ref Vector256<{nativeType}> d{p:00}"));

    string GenerateShuffleX1(string v, string type) => BitonicSizeMap[type] switch {
        4 => $"Shuffle({v}.AsInt32(), X_1).As{BitonicTypeMap[type]}()",
        8 => $"Shuffle({v}.AsDouble(), {v}.AsDouble(), 0b01_01).As{BitonicTypeMap[type]}()",
    };

    string GenerateShuffleX2(string v, string type) => BitonicSizeMap[type] switch {
        4 => $"Shuffle({v}.AsInt32(), X_2).As{BitonicTypeMap[type]}()",
        8 => $"Permute4x64({v}, 0b01_00_11_10).As{BitonicTypeMap[type]}()",
    };

    string GenerateShuffleXR(string v, string type) => BitonicSizeMap[type] switch {
        4 => $"Shuffle({v}.AsInt32(), X_R).As{BitonicTypeMap[type]}()",
        8 => $"Permute4x64({v}, X_R).As{BitonicTypeMap[type]}()",
    };

    string GenerateBlendB1(string v1, string v2, string type) => BitonicSizeMap[type] switch {
        4 => $"Blend({v1}, {v2}, B_1)",
        8 => $"Blend({v1}.AsDouble(), {v2}.AsDouble(), 0b10_10).As{BitonicTypeMap[type]}()",
    };

    string GenerateBlendB2(string v1, string v2, string type) => BitonicSizeMap[type] switch {
        4 => $"Blend({v1}, {v2}, B_2)",
        8 => $"Blend({v1}.AsDouble(), {v2}.AsDouble(), 0b11_00).As{BitonicTypeMap[type]}()",
    };

    string GenerateBlendB4(string v1, string v2, string type) => BitonicSizeMap[type] switch {
        4 => $"Blend({v1}, {v2}, B_4)",
    };

    string GenerateCross(string v, string type) => BitonicSizeMap[type] switch {
        4 => $"Permute4x64({v}.AsInt64(), P_X).As{BitonicTypeMap[type]}()",
    };

    string GenerateReverse(string v, string type) => BitonicSizeMap[type] switch {
        4 => $"Permute4x64(Shuffle({v}.AsInt32(), X_R).AsInt64(), P_X).As{BitonicTypeMap[type]}()",
        8 => $"Permute4x64({v}.AsDouble(), 0b00_01_10_11).As{BitonicTypeMap[type]}()",
    };

    string CrappityCrapCrap(string v1, string v2, string type) => type switch {
        "long" => $"cmp = CompareGreaterThan({v1}, {v2});",
        "ulong" => $"cmp = CompareGreaterThan(Xor(topBit, {v1}.AsInt64()), Xor(topBit, {v2}.AsInt64())).AsUInt64();",
        _ => "",
    };

    string GenerateMin(string v1, string v2, string type) => type switch {
        "int" => $"Min({v1}, {v2})",
        "uint" => $"Min({v1}, {v2})",
        "float" => $"Min({v1}, {v2})",
        "long" => $"BlendVariable({v1}, {v2}, cmp)",
        "ulong" => $"BlendVariable({v1}, {v2}, cmp)",
        "double" => $"Min({v1}, {v2})",
    };

    string GenerateMax(string v1, string v2, string type) => type switch {
        "int" => $"Max({v1}, {v2})",
        "uint" => $"Max({v1}, {v2})",
        "float" => $"Max({v1}, {v2})",
        "long" => $"BlendVariable({v2}, {v1}, cmp)",
        "ulong" => $"BlendVariable({v2}, {v1}, cmp)",
        "double" => $"Max({v1}, {v2})",
    };
    const uint MaxBitonicSortVectors = 16U;

    uint LargestMergeVariantNeeded = GetNextPowerOf2(MaxBitonicSortVectors) / 2;
#>

<#  foreach (var type in BitonicTypes) {
        string MaybeCmp() => (type == "long" || type == "ulong") ? ", cmp" : ""; #>
        [MethodImpl(MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization)]
        static void BitonicSort01VAscending(<#= GenerateParamDefList(1, type) #>)
        {
            // ReSharper disable JoinDeclarationAndInitializer
            Vector256<<#= type #>> min, max, s<#= MaybeCmp() #>;
            // ReSharper restore JoinDeclarationAndInitializer
<#      if (type == "ulong") { #>

            var topBit = Vector256.Create(0x8000000000000000UL).AsInt64();

<#      } #>
            s   = <#= GenerateShuffleX1("d01", type) #>;
            <#= CrappityCrapCrap("s", "d01", type)#>
            min = <#= GenerateMin("s", "d01", type) #>;
            max = <#= GenerateMax("s", "d01", type) #>;
            d01 = <#= GenerateBlendB1("min", "max", type) #>;

            s   = <#= GenerateShuffleXR("d01", type) #>;
            <#= CrappityCrapCrap("s", "d01", type)#>
            min = <#= GenerateMin("s", "d01", type) #>;
            max = <#= GenerateMax("s", "d01", type) #>;
            d01 = <#= GenerateBlendB2("min", "max", type) #>;

            s   = <#= GenerateShuffleX1("d01", type) #>;
            <#= CrappityCrapCrap("s", "d01", type)#>
            min = <#= GenerateMin("s", "d01", type) #>;
            max = <#= GenerateMax("s", "d01", type) #>;
            d01 = <#= GenerateBlendB1("min", "max", type) #>;

<#          if (BitonicSizeMap[type] == 4) { #>
            s   = <#= GenerateReverse("d01", type) #>;
            min = <#= GenerateMin("s", "d01", type) #>;
            max = <#= GenerateMax("s", "d01", type) #>;
            d01 = <#= GenerateBlendB4("min", "max", type) #>;

            s   = <#= GenerateShuffleX2("d01", type) #>;
            min = <#= GenerateMin("s", "d01", type) #>;
            max = <#= GenerateMax("s", "d01", type) #>;
            d01 = <#= GenerateBlendB2("min", "max", type) #>;

            s   = <#= GenerateShuffleX1("d01", type) #>;
            min = <#= GenerateMin("s", "d01", type) #>;
            max = <#= GenerateMax("s", "d01", type) #>;
            d01 = <#= GenerateBlendB1("min", "max", type) #>;
<#          } #>
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization)]
        static void BitonicSort01VDescending(<#= GenerateParamDefList(1, type) #>)
        {
            // ReSharper disable JoinDeclarationAndInitializer
            Vector256<<#= type #>> min, max, s<#= MaybeCmp() #>;
            // ReSharper restore JoinDeclarationAndInitializer

<#      if (type == "ulong") { #>
            var topBit = Vector256.Create(0x8000000000000000UL).AsInt64();
<#      } #>
            s   = <#= GenerateShuffleX1("d01", type) #>;
            <#= CrappityCrapCrap("s", "d01", type)#>
            min = <#= GenerateMin("s", "d01", type) #>;
            max = <#= GenerateMax("s", "d01", type) #>;
            d01 = <#= GenerateBlendB1("max", "min", type) #>;

            s   = <#= GenerateShuffleXR("d01", type) #>;
            <#= CrappityCrapCrap("s", "d01", type)#>
            min = <#= GenerateMin("s", "d01", type) #>;
            max = <#= GenerateMax("s", "d01", type) #>;
            d01 = <#= GenerateBlendB2("max", "min", type) #>;

            s   = <#= GenerateShuffleX1("d01", type) #>;
            <#= CrappityCrapCrap("s", "d01", type)#>
            min = <#= GenerateMin("s", "d01", type) #>;
            max = <#= GenerateMax("s", "d01", type) #>;
            d01 = <#= GenerateBlendB1("max", "min",  type) #>;

<#          if (BitonicSizeMap[type] == 4) { #>
            s   = <#= GenerateReverse("d01", type) #>;
            min = <#= GenerateMin("s", "d01", type) #>;
            max = <#= GenerateMax("s", "d01", type) #>;
            d01 = <#= GenerateBlendB4("max", "min", type) #>;

            s   = <#= GenerateShuffleX2("d01", type) #>;
            min = <#= GenerateMin("s", "d01", type) #>;
            max = <#= GenerateMax("s", "d01", type) #>;
            d01 = <#= GenerateBlendB2("max", "min", type) #>;

            s   = <#= GenerateShuffleX1("d01", type) #>;
            min = <#= GenerateMin("s", "d01", type) #>;
            max = <#= GenerateMax("s", "d01", type) #>;
            d01 = <#= GenerateBlendB1("max", "min", type) #>;
<#          } #>
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization)]
        static void BitonicSort01VMergeAscending(<#= GenerateParamDefList(1, type) #>)
        {
            // ReSharper disable JoinDeclarationAndInitializer
            Vector256<<#= type #>> min, max, s<#= MaybeCmp() #>;
            // ReSharper restore JoinDeclarationAndInitializer
<#      if (type == "ulong") { #>

            var topBit = Vector256.Create(0x8000000000000000UL).AsInt64();

<#      } 
        if (BitonicSizeMap[type] == 4) { #>
            s   = <#= GenerateCross("d01", type) #>;
            min = <#= GenerateMin("s", "d01", type) #>;
            max = <#= GenerateMax("s", "d01", type) #>;
            d01 = <#= GenerateBlendB4("min", "max", type) #>;
<#          } #>
            s   = <#= GenerateShuffleX2("d01", type) #>;
            <#= CrappityCrapCrap("s", "d01", type)#>
            min = <#= GenerateMin("s", "d01", type) #>;
            max = <#= GenerateMax("s", "d01", type) #>;
            d01 = <#= GenerateBlendB2("min", "max", type) #>;

            s   = <#= GenerateShuffleX1("d01", type) #>;
            <#= CrappityCrapCrap("s", "d01", type)#>
            min = <#= GenerateMin("s", "d01", type) #>;
            max = <#= GenerateMax("s", "d01", type) #>;
            d01 = <#= GenerateBlendB1("min", "max", type) #>;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization)]
        static void BitonicSort01VMergeDescending(<#= GenerateParamDefList(1, type) #>)
        {
            // ReSharper disable JoinDeclarationAndInitializer
            Vector256<<#= type #>> min, max, s<#= MaybeCmp() #>;
            // ReSharper restore JoinDeclarationAndInitializer

<#      if (type == "ulong") { #>
            var topBit = Vector256.Create(0x8000000000000000UL).AsInt64();
<#      } #>

<#          if (BitonicSizeMap[type] == 4) { #>
            s   = <#= GenerateCross("d01", type) #>;
            min = <#= GenerateMin("s", "d01", type) #>;
            max = <#= GenerateMax("s", "d01", type) #>;
            d01 = <#= GenerateBlendB4("max", "min", type) #>;
<#          } #>
            s   = <#= GenerateShuffleX2("d01", type) #>;
            <#= CrappityCrapCrap("s", "d01", type)#>
            min = <#= GenerateMin("s", "d01", type) #>;
            max = <#= GenerateMax("s", "d01", type) #>;
            d01 = <#= GenerateBlendB2("max", "min", type) #>;

            s   = <#= GenerateShuffleX1("d01", type) #>;
            <#= CrappityCrapCrap("s", "d01", type)#>
            min = <#= GenerateMin("s", "d01", type) #>;
            max = <#= GenerateMax("s", "d01", type) #>;
            d01 = <#= GenerateBlendB1("max", "min", type) #>;
        }
<#  } #>

<#
    foreach (var type in BitonicTypes) {
        for (var m = 2U; m <= MaxBitonicSortVectors; m++) {
            var s1 = GetNextPowerOf2(m) / 2;
            var s2 = m - s1;
            string MaybeCmp() => (type == "long" || type == "ulong") ? ", cmp" : ""; #>
        [MethodImpl(MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization)]
        static void BitonicSort<#= $"{m:00}" #>VAscending(<#= GenerateParamDefList(m, type) #>)
        {
            Vector256<<#= type #>> tmp<#= MaybeCmp() #>;
<#      if (type == "ulong") { #>
            var topBit = Vector256.Create(0x8000000000000000UL).AsInt64();
<#      } #>
            BitonicSort<#= $"{s1:00}" #>VAscending(<#= GenerateParamList(1, s1) #>);
            BitonicSort<#= $"{s2:00}" #>VDescending(<#= GenerateParamList(s1 + 1, s2) #>);

<#
            for (var r = s1 + 1; r < m + 1; r++) {
                var x = s1 + 1 - (r - s1); #>
            tmp = <#= $"d{r:00}" #>;
            <#= CrappityCrapCrap($"d{x:00}", "tmp", type)#>
            d<#= $"{r:00}" #> = <#= GenerateMax($"d{x:00}", "tmp", type) #>;
            d<#= $"{x:00}" #> = <#= GenerateMin($"d{x:00}", "tmp", type) #>;

<#
            } #>
            BitonicSort<#= $"{s1:00}" #>VMergeAscending(<#= GenerateParamList(1, s1) #>);
            BitonicSort<#= $"{s2:00}" #>VMergeAscending(<#= GenerateParamList(s1 + 1, s2) #>);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization)]
        static void BitonicSort<#= $"{m:00}" #>VDescending(<#= GenerateParamDefList(m, type) #>)
        {
            Vector256<<#= type #>> tmp<#= MaybeCmp() #>;
<#      if (type == "ulong") { #>

            var topBit = Vector256.Create(0x8000000000000000UL).AsInt64();

<#      } #>
            BitonicSort<#= $"{s1:00}" #>VDescending(<#= GenerateParamList(1, s1) #>);
            BitonicSort<#= $"{s2:00}" #>VAscending(<#= GenerateParamList(s1 + 1, s2) #>);

<#
            for (var r = s1 + 1; r < m + 1; r++) {
                var x = s1 + 1 - (r - s1); #>
            tmp = <#= $"d{r:00}" #>;
            <#= CrappityCrapCrap($"d{x:00}", "tmp", type)#>
            d<#= $"{r:00}" #> = <#= GenerateMax($"d{x:00}", "tmp", type) #>;
            d<#= $"{x:00}" #> = <#= GenerateMin($"d{x:00}", "tmp", type) #>;

<#
            } #>
            BitonicSort<#= $"{s1:00}" #>VMergeDescending(<#= GenerateParamList(1, s1) #>);
            BitonicSort<#= $"{s2:00}" #>VMergeDescending(<#= GenerateParamList(s1 + 1, s2) #>);
        }
<#
            if (m <= LargestMergeVariantNeeded) { #>
        [MethodImpl(MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization)]
        static void BitonicSort<#= $"{m:00}" #>VMergeAscending(<#= GenerateParamDefList(m, type) #>)
        {
            Vector256<<#= type #>> tmp<#= MaybeCmp() #>;
<#      if (type == "ulong") { #>

            var topBit = Vector256.Create(0x8000000000000000UL).AsInt64();

<#      } 
    for (var r = s1 + 1; r < m + 1; r++) {
        var x = (r - s1); #>
            tmp = d<#= $"{x:00}" #>;
            <#= CrappityCrapCrap($"d{r:00}", $"d{x:00}", type)#>
            d<#= $"{x:00}" #> = <#= GenerateMin($"d{r:00}", $"d{x:00}", type) #>;
            <#= CrappityCrapCrap($"d{r:00}", "tmp", type)#>
            d<#= $"{r:00}" #> = <#= GenerateMax($"d{r:00}", "tmp", type) #>;

<#
    } #>
            BitonicSort<#= $"{s1:00}" #>VMergeAscending(<#= GenerateParamList(1, s1) #>);
            BitonicSort<#= $"{s2:00}" #>VMergeAscending(<#= GenerateParamList(s1 + 1, s2) #>);
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization)]
        static void BitonicSort<#= $"{m:00}" #>VMergeDescending(<#= GenerateParamDefList(m, type) #>)
        {
            Vector256<<#= type #>> tmp<#= MaybeCmp() #>;

<#      if (type == "ulong") { #>
            var topBit = Vector256.Create(0x8000000000000000UL).AsInt64();
<#      } #>
<#
    for (var r = s1 + 1; r < m + 1; r++) {
        var x = (r - s1); #>
            tmp = d<#= $"{x:00}" #>;
            <#= CrappityCrapCrap($"d{r:00}", $"d{x:00}", type)#>
            d<#= $"{x:00}" #> = <#= GenerateMin($"d{r:00}", $"d{x:00}", type) #>;
            <#= CrappityCrapCrap($"d{r:00}", "tmp", type)#>
            d<#= $"{r:00}" #> = <#= GenerateMax($"d{r:00}", "tmp", type) #>;

<#
    } #>
            BitonicSort<#= $"{s1:00}" #>VMergeDescending(<#= GenerateParamList(1, s1) #>);
            BitonicSort<#= $"{s2:00}" #>VMergeDescending(<#= GenerateParamList(s1 + 1, s2) #>);
        }
<#
            } #>

<#
        } #>

<#
        for (var m = 1U; m <= MaxBitonicSortVectors; m++) { #>
        [MethodImpl(MethodImplOptions.NoInlining | MethodImplOptions.AggressiveOptimization)]
        static void BitonicSort<#= $"{m:00}" #>V(<#= type #>* ptr)
        {
            var N = Vector256<<#= type #>>.Count;

<#  for (var l = 0; l < m; l++) {
        var loadIntrinsic = type switch {
            "float" => "LoadVector256",
            "double" => "LoadVector256",
            _ => "LoadDquVector256"
        }; #>
            var d<#= $"{l + 1:00}" #> = <#= loadIntrinsic #>(ptr + <#= $"{l:00}" #>*N);
<#  } #>

            BitonicSort<#= $"{m:00}" #>VAscending(<#= GenerateParamList(1, m) #>);

<#  for (var l = 0; l < m; l++) { #>
            Store(ptr + <#= $"{l:00}" #>*N, d<#= $"{l + 1:00}" #>);
<#  } #>
        }
<#
        }
    }#>

<#
    foreach (var type in BitonicTypes) { #>
        [MethodImpl(MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization)]
        public static void Sort<#= BitonicTypeMap[type] #>(<#= type #>* ptr, int length)
        {
            var N = Vector256<<#= type #>>.Count;
            Debug.Assert(length % N == 0);
            //Debug.Assert(length <= MaxBitonicSortSize);

            switch (length / N) {
<#
    for (var m = 1U; m <= MaxBitonicSortVectors; m++) { #>
                case <#= $"{m:00}" #>: BitonicSort<#= $"{m:00}" #>V(ptr); return;
<#
    } #>

                default:
                    throw new NotSupportedException("length is not power a multiple of 8 && <= <#= MaxBitonicSortVectors * 8 #>");
            }
        }
<#  } #>



        [MethodImpl(MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization)]
        public static void Sort(T* ptr, int length)
        {
<#  foreach (var type in BitonicTypes) { #>
            if (typeof(T) == typeof(<#= type #>)) {
                Sort<#= BitonicTypeMap[type] #>((<#= type #> *) ptr, length);
            }
            else
<#  } #>
                throw new NotSupportedException();
        }
    }
}
