<#@ template language="C#" #>
<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
// <auto-generated>
//     This code was generated by a tool on <#= $"{DateTime.UtcNow.ToString("yyyy-MM-dd-HH:mm:ss")}"#>
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>

using System;
using System.Diagnostics;
using System.Runtime.CompilerServices;
using System.Runtime.Intrinsics;
using static System.Runtime.Intrinsics.X86.Avx;
using static System.Runtime.Intrinsics.X86.Avx2;

namespace VxSortResearch.Unstable.SmallSort
{
    static unsafe partial class GenericBitonicSort<T>
    {
<#
    static uint GetNextPowerOf2(uint v)
    {
        v--;
        v |= v >> 1;
        v |= v >> 2;
        v |= v >> 4;
        v |= v >> 8;
        v |= v >> 16;
        v++;
        return v;
    }

    // Map supported native types to function suffixes
    Dictionary<string, string> BitonicTypeMap = new Dictionary<string, string> {
        {"int", "Int32"},
        {"uint", "UInt32"},
        {"float", "Float"},
        {"long", "Int64"},
        {"ulong", "UInt64"},
        {"double", "Double"},
    };

    // Map supported native types to function suffixes
    Dictionary<string, int> BitonicSizeMap = new Dictionary<string, int> {
        {"int", 4},
        {"uint", 4},
        {"float", 4},
        {"long", 8},
        {"ulong", 8},
        {"double", 8},
    };
    ICollection<string> BitonicTypes = BitonicTypeMap.Keys;

    string GenerateParamList(uint start, uint numParams)
        => string.Join(", ", Enumerable.Range((int) start, (int) numParams).Select(p => $"ref d{p:00}"));

    string GenerateParamDefList(uint numParams, string nativeType)
        => string.Join(", ", Enumerable.Range(1, (int) numParams).Select(p => $"ref Vector256<{nativeType}> d{p:00}"));

    string GenerateShuffleX1(string v, string type) => BitonicSizeMap[type] switch {
        4 => $"Shuffle({v}, X_1)",
        8 => $"Shuffle({v}.AsDouble(), {v}.AsDouble(), 0b01_01)",
    };

    string GenerateShuffleX2(string v, string type) => BitonicSizeMap[type] switch {
        4 => $"Shuffle({v}, X_2)",
        8 => $"Permute4x64({v}, 0b01_00_11_10)",
    };

    string GenerateShuffleXR(string v, string type) => BitonicSizeMap[type] switch {
        4 => $"Shuffle({v}, X_R)",
        8 => $"Permute4x64(v, X_R)",
    };

    string GenerateBlendB1(string v1, string v2, string type) => BitonicSizeMap[type] switch {
        4 => $"Blend({v1}, {v2}, B_1)",
        8 => $"Blend({v1}.AsDouble(), {v2}.AsDouble(), 0b01_01)",
    };

    string GenerateBlendB2(string v1, string v2, string type) => BitonicSizeMap[type] switch {
        4 => $"Blend({v1}, {v2}, B_2)",
        8 => $"Blend({v1}.AsDouble(), {v2}.AsDouble(), 0b11_00)",
    };

    string GenerateBlendB4(string v1, string v2, string type) => BitonicSizeMap[type] switch {
        4 => $"Blend({v1}, {v2}, B_4)",
    };

    string GenerateMin(string v1, string v2, string type) => type switch {
        "int" => $"Min({v1}, {v2})",
        "uint" => $"Min({v1}, {v2})",
        "float" => $"Min({v1}, {v2})",
        "long" => $"BlendVariable({v1}, {v2}, CompareGreaterThan({v1}, {v2}))",
        "ulong" => $"BlendVariable({v1}, {v2}, CompareGreaterThan(Xor(topBit, {v1}), Xor(topBit, {v2})))",
        "double" => $"Min({v1}, {v2})",
    };

    string GenerateMax(string v1, string v2, string type) => type switch {
        "int" => $"Max({v1}, {v2})",
        "uint" => $"Max({v1}, {v2})",
        "float" => $"Max({v1}, {v2})",
        "long" => $"BlendVariable({v2}, {v1}, CompareGreaterThan({v1}, {v2}))",
        "ulong" => $"BlendVariable({v2}, {v1}, CompareGreaterThan(Xor(topBit, {v1}), Xor(topBit, {v2})))",
        "double" => $"Max({v1}, {v2})",
    };
    const uint MaxBitonicSortVectors = 16U;

    uint LargestMergeVariantNeeded = GetNextPowerOf2(MaxBitonicSortVectors) / 2;
#>

<#
    foreach (var type in BitonicTypes) { #>
        [MethodImpl(MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization)]
        static void BitonicSort01V(<#= GenerateParamDefList(1, type) #>)
        {
            // ReSharper disable JoinDeclarationAndInitializer
            Vector256<<#= type #>> min, max, s;
            // ReSharper restore JoinDeclarationAndInitializer

            var topBit = Vector256.Create(0x8000000000000000UL).AsInt64();

            s   = <#= GenerateShuffleX1("d01", type) #>;
            min = <#= GenerateMin("s", "d01", type) #>;
            max = <#= GenerateMax("s", "d01", type) #>;
            d01 = <#= GenerateBlendB1("min", "max", type) #>;

            s   = <#= GenerateShuffleXR("d01", type) #>;
            min = <#= GenerateMin("s", "d01", type) #>;
            max = <#= GenerateMax("s", "d01", type) #>;
            d01 = <#= GenerateBlendB2("min", "max", type) #>;

            s   = <#= GenerateShuffleX1("d01", type) #>;
            min = <#= GenerateMin("s", "d01", type) #>;
            max = <#= GenerateMax("s", "d01", type) #>;
            d01 = <#= GenerateBlendB1("min", "max", type) #>;
<#          if (BitonicSizeMap[type] == 4) { #>
            s   = Reverse(d01);
            min = <#= GenerateMin("s", "d01", type) #>;
            max = <#= GenerateMax("s", "d01", type) #>;
            d01 = <#= GenerateBlendB4("min", "max", type) #>;

            s   = <#= GenerateShuffleX2("d01", type) #>;
            min = <#= GenerateMin("s", "d01", type) #>;
            max = <#= GenerateMax("s", "d01", type) #>;
            d01 = <#= GenerateBlendB2("min", "max", type) #>;

            s   = <#= GenerateShuffleX1("d01", type) #>;
            min = <#= GenerateMin("s", "d01", type) #>;
            max = <#= GenerateMax("s", "d01", type) #>;
            d01 = <#= GenerateBlendB1("min", "max", type) #>;
        <# } #>
            }

        }

        [MethodImpl(MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization)]
        static void BitonicSort01VMerge(<#= GenerateParamDefList(1, type) #>)
        {
        }

<#  } #>

<#
    string nativeType = "int";
    for (var m = 2U; m <= MaxBitonicSortVectors; m++) {
        var s1 = GetNextPowerOf2(m) / 2;
        var s2 = m - s1; #>
        [MethodImpl(MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization)]
        static void BitonicSort<#= $"{m:00}" #>VGeneric(<#= GenerateParamDefList(m, nativeType) #>)
        {
            Vector256<T> tmp;

            BitonicSort<#= $"{s1:00}" #>VGeneric(<#= GenerateParamList(1, s1) #>);
            BitonicSort<#= $"{s2:00}" #>VGeneric(<#= GenerateParamList(s1 + 1, s2) #>);

<#    for (var r = s1 + 1; r < m + 1; r++) {
           var x = s1 + 1 - (r - s1); #>
            tmp = Reverse(d<#= $"{r:00}" #>);
            d<#= $"{r:00}" #> = <#= GenerateMax($"d{x:00}", "tmp", nativeType) #>;
            d<#= $"{x:00}" #> = <#= GenerateMin($"d{x:00}", "tmp", nativeType) #>;

<#      } #>
            BitonicSort<#= $"{s1:00}" #>VMergeGeneric(<#= GenerateParamList(1, s1) #>);
            BitonicSort<#= $"{s2:00}" #>VMergeGeneric(<#= GenerateParamList(s1 + 1, s2) #>);
        }
<#      if (m <= LargestMergeVariantNeeded) { #>
        [MethodImpl(MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization)]
        static void BitonicSort<#= $"{m:00}" #>VMergeGeneric(<#= GenerateParamDefList(m, nativeType) #>)
        {
            Vector256<T> tmp;

<#        for (var r = s1 + 1; r < m + 1; r++) {
              var x = (r - s1); #>
            tmp = d<#= $"{x:00}" #>;
            d<#= $"{x:00}" #> = <#= GenerateMin($"d{r:00}", $"d{x:00}", nativeType) #>;
            d<#= $"{r:00}" #> = <#= GenerateMax($"d{r:00}", "tmp", nativeType) #>;

<#        } #>
            BitonicSort<#= $"{s1:00}" #>VMergeGeneric(<#= GenerateParamList(1, s1) #>);
            BitonicSort<#= $"{s2:00}" #>VMergeGeneric(<#= GenerateParamList(s1 + 1, s2) #>);
        }
<#      } #>

<#  } #>

<#    for (var m = 1U; m <= MaxBitonicSortVectors; m++) { #>
        [MethodImpl(MethodImplOptions.NoInlining | MethodImplOptions.AggressiveOptimization)]
        static void BitonicSort<#= $"{m:00}" #>V(T* ptr)
        {
            var N = Vector256<T>.Count;

<#
          for (var l = 0; l < m; l++) { #>
            var d<#= $"{l + 1:00}" #> = LoadDquVector256((byte *) ptr + <#= $"{l:00}" #>*N*Unsafe.SizeOf<T>()).As<byte, T>();
<#        } #>

            BitonicSort<#= $"{m:00}" #>VGeneric(<#= GenerateParamList(1, m) #>);

<#
          for (var l = 0; l < m; l++) { #>
            Store((byte *) ptr + <#= $"{l:00}" #>*N*Unsafe.SizeOf<T>(), d<#= $"{l + 1:00}" #>.AsByte());
<#        } #>
        }
<#  } #>

        public const int MinBitonicSortSize = 8;
        public const int MaxBitonicSortSize = <#= MaxBitonicSortVectors * 8 #>;

        [MethodImpl(MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization)]
        public static void Sort(T* ptr, int length)
        {
            var N = Vector256<T>.Count;
            Debug.Assert(length % N == 0);
            Debug.Assert(length <= MaxBitonicSortSize);

            switch (length / N) {
<#    for (var m = 1U; m <= MaxBitonicSortVectors; m++) { #>
                case <#= $"{m:00}" #>: BitonicSort<#= $"{m:00}" #>V(ptr); return;
<#    } #>

                default:
                    throw new NotSupportedException("length is not power a multiple of 8 && <= <#= MaxBitonicSortVectors * 8 #>");
            }
        }
    }
}
